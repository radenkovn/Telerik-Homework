GITHUB LINK : 


Behavioral Patterns Homework
====================

Chain of Responsibility Pattern
---------------------

Chain of Responsibility Pattern е pattern, който съдържа командни обекти и изпълняващи обекти. Всеки изпълняващ обект съдържа логика, която дефинира типовете на командните обекти, с които може да работи, останалите обекти се прехвърлят на следващия изпълняващ обект по нагоре по веригата. Този design pattern позволява лесно да се добавят нови обекти на края на веригата. Друга по-сложна вариация на този design pattern изпълняващите обекти могат да работят като диспечери, които да могат да пращат команди на няколко различни места, като така формират дървета на отговорност. В някои случаи, това може да се случва рекурсивно, като изпълняващите обекти викат обекти, които са нагоре по веригата с команди, които да се опитват да изпълнят малки части от програмата. Така рекурсията продължава, докато командите не се изпълнят или цялото дърво не е било минато. XML интерпретатор е добър пример за това. В Chain of Responsibility изпращачите знаят само за един получател, и всеки получател знае за следващия получател. Важен е редът, в който се изпълнява програмата.


### Class Diagram

![alt tag](http://i.imgur.com/eJIB1PC.png)


Iterator Pattern 
---------------------

Iterator Pattern е design pattern, който се използва, за да се минава през елементите на даден контейнер клас. Понякога Iterator Pattern-ът е абстрактно имплементиран и не е пряко свързан с обекта, но когато са нужни по-сложни алгоритми, това става невъзможно. В такива случаи итераторът е абсолютно couple-нат с обекта, чиито елементи биват итерирани. Смисълът от този design pattern е да се предостави начин, за да се достъпят елементи от даден обект в логически ред, без да се разкриват някои скрити елементи. Най-често Iterator Pattern се прилага като се направи един абстрактен интефейс, който да бъде имплементиран от конкретни итератори за конкретните структури от данни/класове. Повечето програмни езици са имплементирали Iterator Pattern в своите default-ни свойства на езика. В C#, например, foreach цикълът е точно това - ключовата дума yield генерира енумерация. Други езици като C++, Java, Python, и PHP също са включили Iterator Pattern в базовия си синтаксис. 


### Class Diagram

![alt tag](http://i.imgur.com/ccqrFFF.png)


Template Method Pattern 
---------------------

Template Method Pattern e pattern, който дефинира програмния скелета на алгоритъм в метод, наречен Template Method, който оставя някои стъпки на своите наследници. По този начин някои стъпки от алгоритъма могат да бъдат редефинирани, без да се променя неговата структура. Обикновено, за да се имплементира този design pattern, първо се прави абстрактен клас, който да предоставя първоначалните стъпки на дизайна на алгоритъма. Тези стъпки се дефинират чрез абстракстни методи, които по-късно се имплементират от наследниците на класа. Така като цяло алгоритъмът се съхранява на едно място, но конкретните стъпки могат да се сменят от наследниците. Така самият Template Method вика абстрактни и не-абстрактни методи, не-абстрактните биват изцяло контролирани от него, а абстрактните, имплементирани от наследниците, показват точно колко мощен е този design pattern и колко свобода предоставя. Самият Template Method не е абстрактен - той оставя непроменен, като това осигурява правилния ред за изпълняването на алгоритъма.


### Class Diagram

![alt tag](http://i.imgur.com/0vxZQ44.png)