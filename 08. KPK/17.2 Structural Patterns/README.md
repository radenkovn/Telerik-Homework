GITHUB LINK : https://github.com/radenkovn/Telerik-Homework/tree/master/08.%20KPK/17.2%20Structural%20Patterns


Creational Patterns Homework
====================

Facade Pattern
---------------------

Facade Pattern е pattern, който прави използването на някоя дадена библиотека по-лесно и по-опростено. Facade Pattern предоставя прост interface, който да предоставя лесни за тестване и използване методи. Facade Pattern спомага за разбирането на предназначението на библиотеката, върху която е приложен. Тъй като Facade Pattern предоставя свои методи, той не обвързва клиента с предишно имплементиран код, и така се премахват каквито и да е зависимости с досега написания код. Така лесно приложението може да бъде разширено, тъй като по-голямата част от него ползва Facade Pattern методите. Facade Pattern е също и начин едно не-толкова добре написно API да се превърне в API с много по-приемлив дизайн. Най-често, този pattern се ползва когато сложна система има нужда от лесно ползване, когато абстракциите и имплементациите в дадена система са прекалено взаимно-обвързани, или когато просто дадена система е прекалено трудна за разбиране. Този design pattern може да бъде заменен/комбиниран с pattern-и като Adapter и Decorator.


### Class Diagram

![alt tag](http://i.imgur.com/gi7zrz3.png)


Composite Pattern
---------------------

Composite Pattern e pattern, който се използва, когато е необходимо няколко подобни обекта да се третират по същия начин като само един обект. Смисълът от този design pattern e обектите да се разделят на структури-дървета. Composite Pattern се използва, когато клиентът не може да направи разлика между отделните обекти, от които е композиран кодът. Когато програмист открие, че често ползва различни обекти по един и същи начин и често използва почти един и същи имплементиран код за отделните обекти, тогава Composite Pattern е добър избор. Component e абстракцията, която декларира interface-а за обектите, които за част от композицията. Leaf е "листо", което е част от композицията. Самата композиция имплементира методите, които да ползват наследници. В нея се дефинират всички методи, които се делегират на наследниците. Смисълът от Composite Pattern е, че по същия начин, по който се манипулира един обект, се манипулира и група от обекти.   


### Class Diagram

![alt tag](http://i.imgur.com/oG8vsa5.png)


Proxy Pattern
---------------------

Proxy Pattern в най-общия случай е клас, който се използва като interface за друг клас. Това може да се отнася за всичко: обемен файл, голям ресурс, нещо невъзможно за дубликиране, или за достъпване. На кратко, Proxy обектът служи като обвивка или използвач, който се вика от клиента, без клиентът да има пряк достъп до обекта зад Proxy обекта. Понякога Proxy обектът може да добавя нова функционалност, без да променя имплементацията на този обект, или кода му. Proxy Pattern може да се ползва в много случаи като тези: добавяне на сигурност към обект - Proxy обектът решава дали клиентът има достъп до обекта; опростяване на API-то на комплексни обекти - Proxy Pattern може да предостави по-лесен начин за използването на обекта, зада улесни неготово ползване за клиента; координиране на операции, които изискват много ресурси; добавяне на thread-safe функционалност. Когато се налага огромен(на памент) обект да бъде инстанциран няколко пъти, това може да се предотврати чрез Proxy Pattern, като няколко Proxy обекта бъдат инстанцирани, които пазят референция в паметта си за този обект - когато те приключат работа с обекта, паметта, отделена за него може да бъде изчистена.


### Class Diagram

![alt tag](http://i.imgur.com/U3lRDR4.png)